/*
 * File created 14.11.2021, last modified 07.01.2022
 *
 * The e.c file is part of the restored LINK.COM program
 * from the Hi-Tech C compiler v3.09 package.
 *
 *	Andrey Nikitin & Mark Ogden	07.01.2022
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "link.h"

/**************************************************************************
 61	finPass2	ok++ (PMO)
 **************************************************************************/
void finPass2() {

    flushText();
    wrRecord();
    if (!key_R && !key_C) {
        if (haveEntryPt == 0) {
            warning("no start record: entry point defaults to zero");
            conv_u32tob(0, recbuf + START_OFFSET);
            recbuf[START_PNAME] = 0;
            writeRec(START_RECORD, 5, recbuf);
        }
    }

    conv_u16tob(0, recbuf);
    if (!key_C)
        writeRec(END_RECORD, 2, recbuf); /* PMO - note doesn't write the 0 for PSECT name !!*/
    if (key_M == 0)
        return;
    wr_linkmap(); /*  Write a link map */
}

/**************************************************************************
 62	wrSymbol	ok++ (PMO)
 *
 * optimiser uses marginally better code (1 byte less) for the calculation
 * in final strcpy
 **************************************************************************/
void wrSymbol(register sym_t *ps) {
    sym_t *psectSym;
    char  *symbol_name;
    char  *psect_name;
    size_t len;

    symbol_name = ps->name;
    psect_name  = (psectSym = ps->psectSym) ? psectSym->name : "";

    if (fname_sym)
        prSymbol(symbol_name, ps->p.value, SF_NULL, psectSym);

    if (key_C)
        return;
    /* Write to the object file */
    len = SYM_PNAME + strlen(symbol_name) + 1 + strlen(psect_name) + 1;

    chkAddRecordItem(SYM_RECORD, len);                     /* make enough room */
    conv_u32tob(ps->p.value, nonTextRecPtr + SYM_VALUE);   /* save the value */
    conv_u16tob(ps->flags, nonTextRecPtr + SYM_FLAGS);     /* and the flags */
    strcpy((char *)nonTextRecPtr + SYM_PNAME, psect_name); /* psect name & symbol name */
    strcpy(strlen(psect_name) + SYM_PNAME + 1 + (char *)nonTextRecPtr, symbol_name);
    nonTextRecPtr += len; /* undate for next entry */
}

/**************************************************************************
 63	isLocalName	ok++ (PMO)
 * locals generated by the compiler of form
 * [klfFLS] \d*
 **************************************************************************/
char isLocalName(register char *st) {

    if (strchr("klfFLS", *st) == 0)
        return 0;

    while (isdigit(*++st))
        ;
    return *st == 0;
}

/**************************************************************************
 64	prFileLinkMap	ok++ (PMO)
 **************************************************************************/
void prFileLinkMap() {
    uint32_t addr;
    int nCols, col;
    register psect_t *pp;

    if (strlen(fname_obj) < 16)
        printf("%-16.15s", fname_obj); /* Print name obj file */
    else
        printf("%s\n%16s", fname_obj, "");

    col           = 0;
    nCols           = (width - 10) / 32;
    absSym->name  = "(abs)"; /* for printing */

    for (pp = psectInfo; pp != nextPsect; ++pp) {
        if (pp->endAddr != 0) {
            if (pp->psectSym->flags & SF_OVRLD)
                addr = 0;
            else
                addr = pp->blkStartAddress;
            if (!key_R)
                addr += pp->linkAddress;
            if (nCols < ++col) { /* m6: */
                printf("\n\t\t");
                col = 1;
            } else if (col > 1)
                    fputc('\t', stdout);
            printf("%-8.8s %8" PRIx32 " %8" PRIx32, pp->psectSym->name, addr, pp->endAddr); /* m8: */
        }
    }
    fputc('\n', stdout);
    absSym->name = ""; /* revert */
}

/**************************************************************************
 65	output_summary	sub_36f3h	ok++ (PMO)
 **************************************************************************/
void output_summary(register psect_t *st) {

    printf("\t\t%-8.8s ", st->psectSym->name); 		/* Name   */

    if (key_R != 0) { /* Link   */
        printf("%8c", 0x20);
    } else {
        printf("%8" PRIx32, st->linkAddress);
    }
    printf(" %8" PRIx32, st->loadAddress);       	/* Load   */
    printf(" %8" PRIx32 "\n", st->blkStartAddress); 	/* Length */
}

/**************************************************************************
 66	wr_linkmap	sub-3773	ok++ (PMO)
 *	Write a link map
 **************************************************************************/
void wr_linkmap() {
    sym_t  **pSlot;
    psect_t *l2;
    psect_t *l3;
    uint8_t  i;
    uint8_t  symColWidth;
    uint8_t  nCol;
    uint8_t  psectColWidth;
    register sym_t *ps;

    /* 997 */
    qsort(symbol_table, MAX_SYMBOLS, sizeof(symbol_table[0]), compare_fun);
    absSym->name = "(abs)"; /* For printing use (abs) rather than "" */
    for (pSlot = symbol_table, symColWidth = 0, psectColWidth = 0; ps = *pSlot; pSlot++) {
        i = (uint8_t)strlen(ps->name);
        if ((ps->flags & 0xC000) != 0) {
            if (psectColWidth < i)
                psectColWidth = i;
        } else if (symColWidth < i)
            symColWidth = i; /* m2: */
    }
    fputc('\n', stdout);

    printf("TOTAL\t\tName         Link     Load   Length\n");
    for (l2 = psectInfo, i = 0; l2 != nextPsect; l2++, i++) {
        if (l2->classSym == 0) {
            if (l2->psectSym->flags & SF_CLASS) {
                printf("\tCLASS.%-8.8s\n", l2->psectSym->name);
                for (l3 = psectInfo; l3 != nextPsect; ++l3) { /* m8: */
                    if (l3->classSym == l2->psectSym)
                        output_summary(l3); /* m6: */
                }
                fputc('\n', stdout);
            } else
                output_summary(l2);
        }
    }
    fputc('\n', stdout);

    for (i = (width - 12) / 2; 0 < i; i--)
        fputc(' ', stdout);

    printf("%s\n\n", "Symbol Table");
    nCol  = width / (symColWidth + psectColWidth + 8);
    pSlot = symbol_table;

    for (i = 0; ps = *pSlot; pSlot++) {
        if ((ps->flags & 0xC000) == 0) {
            printf("%-*s", symColWidth, ps->name);
            if ((ps->flags & 0xF) == SF_EXTERN)
                printf("%*c", psectColWidth + 6, ' ');
            else
                printf(" %-*s %04X", psectColWidth, ps->psectSym->name, ps->p.value);
            if (++i >= nCol) {
                i = 0;
                fputc('\n', stdout);
            } else
                printf("  "); /* m17: */
        }
    }
    if (i != 0)
        fputc('\n', stdout);
    absSym->name = ""; /* revert to "" */
}

/**************************************************************************
 67	compare_fun	sub_3a5b	ok++ (PMO)
 **************************************************************************/
int compare_fun(const void *p1, const void *p2) {
    register const sym_t *ps1;
    const sym_t *ps2;

    ps1 = *(const sym_t **)p1;
    ps2 = *(const sym_t **)p2;

    if (ps2 == ps1)
        return 0;
    if (ps1 == 0)
        return 1;
    if (ps2 == 0)
        return -1;
    if (key_N != 0) { /* Sort symbols by address */
        if ((ps1->flags & 0xC000) == 0 && (ps2->flags & 0xC000) == 0) {
            if (ps1->p.value != ps2->p.value) {
                if (ps1->p.value >= ps2->p.value)
                    return 1;
                return -1;
            } /* if equal sort by name below */
        }
    }

    return strcmp(ps1->name, ps2->name); /* m7: */
}

/**************************************************************************
 68	textRecPass1	ok++ (PMO)
 **************************************************************************/
int textRecPass1() {
    uint32_t endAddr;
    char *psectName;
    int textLen;
    register sym_t *ps;

    readRecData(textRecBuf); /* Read TEXT record to textRecBuf */

    psectName = (char *)textRecBuf + TEXT_PNAME;                    /* ptr to name psectSym */
    textLen   = length - (int)(TEXT_PNAME + strlen(psectName) + 1); /* number of data bytes */

    if (textLen < 0)
        badFormat("text record has bad length: %d-%d-(%d+1) < 0", length, TEXT_PNAME,
                  strlen(psectName));

    endAddr = conv_btou32(textRecBuf) + textLen; /* Offset+number of data bytes      */
    ps      = addSym(psectName, SF_PSECT);       /* find the psectSym symbol         */
    if (ps->p.pinfo->endAddr < endAddr)          /* update psectSym end if necessary */
        ps->p.pinfo->endAddr = endAddr;
    return textLen;
}

/**************************************************************************
 69	textRecPass2	ok++ (PMO)
 **************************************************************************/
void textRecPass2() {
    uint32_t l1;
    psect_t *l2;
    register sym_t *ps;

    flushText();
    wrRecord();

    alreadyWritten = 0;
    textLen        = textRecPass1();          /* number of data bytes */
    textRecPtr     = textRecBuf + TEXT_PNAME; /* ptr to name psectSym */

    while (*textRecPtr++ != 0) /* skip name psectSym */
        ;

    endAddr = textRecPtr; /* ptr to start data psectSym */
    curAddr = textRecPtr;

    ps      = addSym((char *)textRecBuf + TEXT_PNAME, SF_PSECT); /* ptr to symbol table */
    l1      = conv_btou32(textRecBuf + TEXT_OFFSET);     /* Offset */
    l2      = ps->p.pinfo;

    if (!(ps->flags & SF_OVRLD))
        l1 += l2->blkStartAddress;

    textBaseAddress = l1;

    if (!key_R) {
        l1 += l2->loadAddress;

        textBaseAddress += l2->linkAddress;
    }
    conv_u32tob(l1, textRecBuf + TEXT_OFFSET); /* m3: */
}

/**************************************************************************
 70	startRecPass2	ok++ (PMO)
 **************************************************************************/
void startRecPass2() {
    uint32_t l1;
    register psect_t *pp;

    if (haveEntryPt != 0)
        simpl_err("entry point multiply defined");

    haveEntryPt = true;

    readRecData(recbuf);

    if (key_C)
        return;

    l1 = conv_btou32(recbuf);

    pp = addSym((char *)recbuf + START_PNAME, SF_PSECT)->p.pinfo;

    l1 += pp->blkStartAddress;

    if (!key_R)
        l1 += pp->linkAddress;

    conv_u32tob(l1, recbuf);
    writeRec(START_RECORD, START_PNAME + (int)strlen((char *)recbuf + START_PNAME) + 1, recbuf);
}

/**************************************************************************

       #######                     #         ###   #     #  #    #
       #        #    #  #####      #          #    ##    #  #   #
       #        ##   #  #    #     #          #    # #   #  #  #
       #####    # #  #  #    #     #          #    #  #  #  ###
       #        #  # #  #    #     #          #    #   # #  #  #
       #        #   ##  #    #     #          #    #    ##  #   #
       #######  #    #  #####      #######   ###   #     #  #    */
